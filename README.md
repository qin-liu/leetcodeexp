#### 771. Jewels and Stones
该题是计算石头中有多少个是珠宝，根据官方提供的两种答案，有两种标记算法，一种是用map标记，一种是用数组标记，这一题由于类型限制在了26个字母，所以应该想到用可以数组标记，因为字母个数限定了为26个，数组下标通过 smallLetter[c - 'a'] 和 bigLetter[c = 'A']来索引该字母是否被标记，数组标记减少了map的插入和查找，所以更快。

#### 804. Unique Morse Code Words
该题是一个去重的问题，通过map或者set插入就可以快速去重。morse编码用一个数组或者map存储即可。

#### 461. Hamming Distance
该题是比较整数的比特位的问题，直接用异或比较出两个数的不同的位，再将该结果循环移位和1比较，简单点的写法更可以一位一位的比较：

```
for ; x != 0 || y != 0; x , y = x >> 1, y >> 1 {
    if (x & 1) != (y & 1) {
        distance++
    }
}

#### 476. Number Complement
该题思路是将num用异或^来求解，比如101 ^ 111 = 010。那么怎么得到111呢？考虑111 + 1 = 1000，判断出第几位第一次出现1就可以了。可以对num进行右移，如果大于0说明还有为1的位。

#### 627. Swap Salary
主要用到 sql 语法 CASE WHEN END  或者 IF（）函数

#### 657. Judge Route Circle
该题思路比较简单，判断是否回到源点只要判断移动路径总路径和为0即可，向上和向右 += 1， 向左和向下 -= 1，判断和为0

#### 617. Merge Two Binary Trees
合并两个二叉树问题，首先肯定的是要利用递归。然后根据情况判断，如果t1、t2都不为空，则计算新节点的值，再遍历新节点的左子树和右子树。如果t1、t2有一个不为空，则直接返回不为空的节点即可。